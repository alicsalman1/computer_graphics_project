#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

bool intersectBoundingBox(vec4 origin, vec4 dir) {
	// TODO
  vec3 dir_inv = 1/dir.xyz;
  double tx1 = (bbmin.x - origin.x)*dir_inv.x;
  double tx2 = (bbmax.x - origin.x)*dir_inv.x;

  double tmin = min(tx1, tx2);
  double tmax = max(tx1, tx2);

  double ty1 = (bbmin.y - origin.y)*dir_inv.y;
  double ty2 = (bbmax.y - origin.y)*dir_inv.y;

  tmin = max(tmin, min(ty1, ty2));
  tmax = min(tmax, max(ty1, ty2));

  double tz1 = (bbmin.z - origin.z)*dir_inv.z;
  double tz2 = (bbmax.z - origin.z)*dir_inv.z;

  tmin = max(tmin, min(tz1, tz2));
  tmax = min(tmax, max(tz1, tz2));

  return tmax >= tmin;
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
	// TODO

  vec3 v0 = vertices[indices[ptr]].xyz;
  vec3 v1 = vertices[indices[ptr + 1]].xyz;
  vec3 v2 = vertices[indices[ptr + 2]].xyz;
  vec3 e1 = v1 - v0;
  vec3 e2 = v2 - v0;
  vec3 tVec = origin.xyz - v0;
  vec3 pVec = cross(dir.xyz,e2);
  vec3 qVec = cross(tVec,e1);
  float det = dot(pVec,e1) ;

  // if the determinant is negative the triangle is backfacing
  // if the determinant is close to 0, the ray misses the triangle
  if (det < EPS) return false;
  // ray and triangle are parallel if det is close to 0
  if (abs(det) < EPS) return false;

  //else
  float invDet = 1 / det;

  float u = dot(tVec,pVec) * invDet;
  if (u < 0 || u > 1) return false;

  float v = dot(dir.xyz,qVec) * invDet;
  if (v < 0 || u + v > 1) return false;

  float t = dot(e2,qVec) * invDet;

  dist = vec4(u,v,1-u-v,t);

  return true;

}

vec4 interpolateNormal(hitinfo_t h)
{
	// TODO
    return vec4(1);
}

vec4 interpolateColor(hitinfo_t h)
{
	// TODO
	return vec4(1);
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
				// TODO
        hit = true;
			}
		}
	}
	return hit;
}

const int MAX_TRACE = 1;


vec4 trace(vec4 origin, vec4 dir)
{
	// TODO: trace a ray in the scene, see what it intersects, bounce around
  hitinfo_t h;
  if (isIntersected(origin,dir,h))
        return vec4(1,0,0,1);
    else
        return vec4(1,1,1,1);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {

    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    imageStore(framebuffer, pix, color);
}
